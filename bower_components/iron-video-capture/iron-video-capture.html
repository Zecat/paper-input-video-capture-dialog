<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">

<!--
An element extending the native video element, make it easy to capture a video frame. 
Usefull for a user to choose a video's image preview.
For now, it just capture the current frame.

  ```html
  <template is="dom-bind" id="scope">

    <style>
      video {
        width: 420px;
        height: 315px;
      }
      img {
        width: 200px;
        height: auto;
      }
    </style>

    <video is="iron-video-capture" id="video"
      controls loop src="video/video.mp4"
      capture-url="{{captureUrl}}" capture-width="200">
    </video>
    <img src="[[captureUrl]]">
    <button on-tap="capture">Prendre une capture</button>
      
  </template>

    <script>
      var scope = document.getElementById('scope');
      scope.capture = function() {
        this.$.video.capture();
      }
    </script>

  ```

## Warning: provide the video from your domaine

Internally it use a canvas element, due to CORS, the video can not come from 
an external domaine, otherwise, you'll receive a "Uncaught SecurityError: 
Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may 
not be exported.". Tell me if you find a solution about that !

@group Iron Elements
@element iron-video-capture
@demo demo/index.html
@hero hero.svg
-->

<script>

  Polymer({

    is: 'iron-video-capture',

    extends: 'video',

    properties: {
      /**
       * The url of the last capture.
       */
      captureUrl: {
        type: String,
        value: '',
        notify: true
      },
      /**
       * The width of the capture. Height is calculated proportionally.
       */
      captureWidth:  {
        type: Number,
        value: 0
      },
      /**
       * The native video's src attribute.
       */
      src: {
        type: String,
        value: ''
      },
      /**
       * The canvas used to extract a video frame.
       */
      _canvas: {
        type: Object,
        value : function() {
          return document.createElement('canvas');
        }
      }
    },
    /**
     * Take a capture of the current video's frame and expose it as data URL (type png) within captureUrl attribute.
     */
    capture: function() {
      // if a video is present
      if (this.videoWidth) {
        // to call in observer on this.captureWidth & native video.videoWidth var
        this._ensureResize();
        this._canvas.getContext('2d').drawImage(this, 0, 0);
        this.captureUrl = this._canvas.toDataURL();
      }
    },
    /**
     *  Call this method when you've finished using capture's Url, in order 
     *  to let the browser know it doesn't need to keep the reference to the 
     *  file any longer.
     */
    revokeCapture: function() {
      URL.revokeObjectURL(this.captureUrl);
    },
    _ensureResize: function() {
      if (this._canvas.width != this.captureWidth) {
        this._canvas.getContext('2d').resetTransform();
        var scaleFactor = this.captureWidth / this.videoWidth;
        this._canvas.width = this.captureWidth;
        this._canvas.height = this.videoHeight * scaleFactor;
        this._canvas.getContext('2d').scale(scaleFactor, scaleFactor);
        this.revokeCapture();
        this.captureUrl = this._canvas.toDataURL();
      }
    }

  });

</script>
